/*
 * Copyright (c) 2016-2023 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
import { DOCUMENT } from '@angular/common';
import { Directive, EventEmitter, Inject, Input, } from '@angular/core';
import { debounceTime } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "./providers/popover-position.service";
import * as i2 from "./providers/popover-events.service";
import * as i3 from "./providers/popover-toggle.service";
// https://github.com/angular/angular/issues/20351#issuecomment-344009887
/** @dynamic */
export class ClrPopoverContent {
    constructor(document, container, template, renderer, smartPositionService, smartEventsService, smartOpenService) {
        this.document = document;
        this.container = container;
        this.template = template;
        this.renderer = renderer;
        this.smartPositionService = smartPositionService;
        this.smartEventsService = smartEventsService;
        this.smartOpenService = smartOpenService;
        this.subscriptions = [];
        this.removeClickListenerFn = null;
        this.shouldRealign = false;
        // Check-collector pattern:
        // In order to get accurate content height/width values, we cannot calculate alignment offsets until
        // after the projected content has stabilized.
        // As multiple check events may happen in the same rendering cycle, we need to collect all events
        // and only act after the content is really stable. Or we may get wrong intermediate positioning values.
        // We will channel subsequent content check events through this observable.
        this.checkCollector = new EventEmitter();
    }
    set open(value) {
        this.smartOpenService.open = !!value;
    }
    set contentAt(position) {
        this.smartPositionService.position = position;
    }
    set outsideClickClose(clickToClose) {
        this.smartEventsService.outsideClickClose = !!clickToClose;
    }
    set scrollToClose(scrollToClose) {
        this.smartEventsService.scrollToClose = !!scrollToClose;
    }
    ngAfterViewInit() {
        this.subscriptions.push(this.smartOpenService.openChange.subscribe(change => {
            if (change) {
                this.addContent();
            }
            else {
                this.removeContent();
            }
        }), this.smartPositionService.shouldRealign.subscribe(() => {
            this.shouldRealign = true;
            // Avoid flickering on initialization, caused by the asynchronous nature of the
            // check-collector pattern.
            if (this.view) {
                this.renderer.setStyle(this.view.rootNodes[0], 'opacity', '0');
            }
        }), 
        // Here we collect subsequent synchronously received content-check events and only take action
        // at the end of the cycle. See below for details on the check-collector pattern.
        this.checkCollector.pipe(debounceTime(0)).subscribe(() => {
            this.alignContent();
            this.shouldRealign = false;
            if (this.view) {
                this.renderer.setStyle(this.view.rootNodes[0], 'opacity', '1');
            }
        }));
    }
    ngOnDestroy() {
        this.removeContent();
        this.subscriptions.forEach(sub => sub.unsubscribe());
    }
    removeContent() {
        if (!this.view) {
            return;
        }
        if (this.removeClickListenerFn) {
            this.removeClickListenerFn();
            this.removeClickListenerFn = null;
        }
        this.view.rootNodes.forEach(node => this.renderer.removeChild(this.document.body, node));
        this.container.clear();
        delete this.view;
    }
    /**
     * TODO(matt): investigate why DebugElement retains a reference to the nodes and causes a memory leak.
     * A note about the use of appendChild/removeChild
     * The DebugElement is keeping a reference to the detached node and its unclear why.
     * This does warrant further investigation. But, since it doesn't happen in production mode
     * it is a low priority issue for now.
     */
    addContent() {
        // Create the view container
        this.view = this.container.createEmbeddedView(this.template);
        const [rootNode] = this.view.rootNodes;
        this.smartEventsService.contentRef = rootNode; // So we know where/what to set close focus on
        this.renderer.addClass(rootNode, 'clr-popover-content');
        // Reset to the begining of the document to be available for sizing/positioning calculations.
        // If we add new content to the bottom it triggers changes in the layout that may lead to false anchor
        // coordinates values.
        this.renderer.setStyle(rootNode, 'top', '0px');
        this.renderer.setStyle(rootNode, 'left', '0px');
        // We need to hide it during the calculation phase, while it's not yet finally positioned.
        this.renderer.setStyle(rootNode, 'opacity', '0');
        this.removeClickListenerFn = this.renderer.listen(rootNode, 'click', event => {
            this.smartOpenService.openEvent = event;
        });
        this.view.rootNodes.forEach(node => {
            this.renderer.appendChild(this.document.body, node);
        });
        // Mark for realingment on the next content-check cycle.
        this.shouldRealign = true;
    }
    ngAfterContentChecked() {
        if (this.smartOpenService.open && this.view && this.shouldRealign) {
            // Channel content-check event through the check-collector
            this.checkCollector.emit();
        }
    }
    alignContent() {
        if (!this.view) {
            return;
        }
        const positionCoords = this.smartPositionService.alignContent(this.view.rootNodes[0]);
        this.renderer.setStyle(this.view.rootNodes[0], 'top', `${positionCoords.yOffset}px`);
        this.renderer.setStyle(this.view.rootNodes[0], 'left', `${positionCoords.xOffset}px`);
        this.smartOpenService.popoverAlignedEmit(this.view.rootNodes[0]);
    }
}
ClrPopoverContent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.11", ngImport: i0, type: ClrPopoverContent, deps: [{ token: DOCUMENT }, { token: i0.ViewContainerRef }, { token: i0.TemplateRef }, { token: i0.Renderer2 }, { token: i1.ClrPopoverPositionService }, { token: i2.ClrPopoverEventsService }, { token: i3.ClrPopoverToggleService }], target: i0.ɵɵFactoryTarget.Directive });
ClrPopoverContent.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.3.11", type: ClrPopoverContent, selector: "[clrPopoverContent]", inputs: { open: ["clrPopoverContent", "open"], contentAt: ["clrPopoverContentAt", "contentAt"], outsideClickClose: ["clrPopoverContentOutsideClickToClose", "outsideClickClose"], scrollToClose: ["clrPopoverContentScrollToClose", "scrollToClose"] }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.11", ngImport: i0, type: ClrPopoverContent, decorators: [{
            type: Directive,
            args: [{
                    selector: '[clrPopoverContent]',
                }]
        }], ctorParameters: function () { return [{ type: Document, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }, { type: i0.ViewContainerRef }, { type: i0.TemplateRef }, { type: i0.Renderer2 }, { type: i1.ClrPopoverPositionService }, { type: i2.ClrPopoverEventsService }, { type: i3.ClrPopoverToggleService }]; }, propDecorators: { open: [{
                type: Input,
                args: ['clrPopoverContent']
            }], contentAt: [{
                type: Input,
                args: ['clrPopoverContentAt']
            }], outsideClickClose: [{
                type: Input,
                args: ['clrPopoverContentOutsideClickToClose']
            }], scrollToClose: [{
                type: Input,
                args: ['clrPopoverContentScrollToClose']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9wb3Zlci1jb250ZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvYW5ndWxhci9zcmMvdXRpbHMvcG9wb3Zlci9wb3BvdmVyLWNvbnRlbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7R0FJRztBQUVILE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUMzQyxPQUFPLEVBRUwsU0FBUyxFQUVULFlBQVksRUFDWixNQUFNLEVBQ04sS0FBSyxHQUtOLE1BQU0sZUFBZSxDQUFDO0FBRXZCLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQzs7Ozs7QUFPOUMseUVBQXlFO0FBQ3pFLGVBQWU7QUFJZixNQUFNLE9BQU8saUJBQWlCO0lBMEI1QixZQUM0QixRQUFrQixFQUNwQyxTQUEyQixFQUMzQixRQUEwQixFQUMxQixRQUFtQixFQUNuQixvQkFBK0MsRUFDL0Msa0JBQTJDLEVBQzNDLGdCQUF5QztRQU52QixhQUFRLEdBQVIsUUFBUSxDQUFVO1FBQ3BDLGNBQVMsR0FBVCxTQUFTLENBQWtCO1FBQzNCLGFBQVEsR0FBUixRQUFRLENBQWtCO1FBQzFCLGFBQVEsR0FBUixRQUFRLENBQVc7UUFDbkIseUJBQW9CLEdBQXBCLG9CQUFvQixDQUEyQjtRQUMvQyx1QkFBa0IsR0FBbEIsa0JBQWtCLENBQXlCO1FBQzNDLHFCQUFnQixHQUFoQixnQkFBZ0IsQ0FBeUI7UUEvQjNDLGtCQUFhLEdBQW1CLEVBQUUsQ0FBQztRQXNCbkMsMEJBQXFCLEdBQXdCLElBQUksQ0FBQztRQXlGbEQsa0JBQWEsR0FBRyxLQUFLLENBQUM7UUFFOUIsMkJBQTJCO1FBQzNCLG9HQUFvRztRQUNwRyw4Q0FBOEM7UUFDOUMsaUdBQWlHO1FBQ2pHLHdHQUF3RztRQUN4RywyRUFBMkU7UUFDbkUsbUJBQWMsR0FBdUIsSUFBSSxZQUFZLEVBQUUsQ0FBQztJQXZGN0QsQ0FBQztJQTlCSixJ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Z0JBTXhCLGlCQUFpQjtzQkFEcEIsS0FBSzt1QkFBQyxzQ0FBc0M7Z0JBTXpDLGFBQWE7c0JBRGhCLEtBQUs7dUJBQUMsZ0NBQWdDIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDIzIFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBET0NVTUVOVCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge1xuICBBZnRlckNvbnRlbnRDaGVja2VkLFxuICBEaXJlY3RpdmUsXG4gIEVtYmVkZGVkVmlld1JlZixcbiAgRXZlbnRFbWl0dGVyLFxuICBJbmplY3QsXG4gIElucHV0LFxuICBPbkRlc3Ryb3ksXG4gIFJlbmRlcmVyMixcbiAgVGVtcGxhdGVSZWYsXG4gIFZpZXdDb250YWluZXJSZWYsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBkZWJvdW5jZVRpbWUgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbmltcG9ydCB7IENsclBvcG92ZXJQb3NpdGlvbiB9IGZyb20gJy4vaW50ZXJmYWNlcy9wb3BvdmVyLXBvc2l0aW9uLmludGVyZmFjZSc7XG5pbXBvcnQgeyBDbHJQb3BvdmVyRXZlbnRzU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL3BvcG92ZXItZXZlbnRzLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2xyUG9wb3ZlclBvc2l0aW9uU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL3BvcG92ZXItcG9zaXRpb24uc2VydmljZSc7XG5pbXBvcnQgeyBDbHJQb3BvdmVyVG9nZ2xlU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL3BvcG92ZXItdG9nZ2xlLnNlcnZpY2UnO1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy8yMDM1MSNpc3N1ZWNvbW1lbnQtMzQ0MDA5ODg3XG4vKiogQGR5bmFtaWMgKi9cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1tjbHJQb3BvdmVyQ29udGVudF0nLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJQb3BvdmVyQ29udGVudCBpbXBsZW1lbnRzIEFmdGVyQ29udGVudENoZWNrZWQsIE9uRGVzdHJveSB7XG4gIHByaXZhdGUgdmlldzogRW1iZWRkZWRWaWV3UmVmPHZvaWQ+O1xuICBwcml2YXRlIHN1YnNjcmlwdGlvbnM6IFN1YnNjcmlwdGlvbltdID0gW107XG5cbiAgQElucHV0KCdjbHJQb3BvdmVyQ29udGVudCcpXG4gIHNldCBvcGVuKHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5zbWFydE9wZW5TZXJ2aWNlLm9wZW4gPSAhIXZhbHVlO1xuICB9XG5cbiAgQElucHV0KCdjbHJQb3BvdmVyQ29udGVudEF0JylcbiAgc2V0IGNvbnRlbnRBdChwb3NpdGlvbjogQ2xyUG9wb3ZlclBvc2l0aW9uKSB7XG4gICAgdGhpcy5zbWFydFBvc2l0aW9uU2VydmljZS5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICB9XG5cbiAgQElucHV0KCdjbHJQb3BvdmVyQ29udGVudE91dHNpZGVDbGlja1RvQ2xvc2UnKVxuICBzZXQgb3V0c2lkZUNsaWNrQ2xvc2UoY2xpY2tUb0Nsb3NlOiBib29sZWFuKSB7XG4gICAgdGhpcy5zbWFydEV2ZW50c1NlcnZpY2Uub3V0c2lkZUNsaWNrQ2xvc2UgPSAhIWNsaWNrVG9DbG9zZTtcbiAgfVxuXG4gIEBJbnB1dCgnY2xyUG9wb3ZlckNvbnRlbnRTY3JvbGxUb0Nsb3NlJylcbiAgc2V0IHNjcm9sbFRvQ2xvc2Uoc2Nyb2xsVG9DbG9zZTogYm9vbGVhbikge1xuICAgIHRoaXMuc21hcnRFdmVudHNTZXJ2aWNlLnNjcm9sbFRvQ2xvc2UgPSAhIXNjcm9sbFRvQ2xvc2U7XG4gIH1cblxuICBwcml2YXRlIHJlbW92ZUNsaWNrTGlzdGVuZXJGbjogVm9pZEZ1bmN0aW9uIHwgbnVsbCA9IG51bGw7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgQEluamVjdChET0NVTUVOVCkgcHJpdmF0ZSBkb2N1bWVudDogRG9jdW1lbnQsXG4gICAgcHJpdmF0ZSBjb250YWluZXI6IFZpZXdDb250YWluZXJSZWYsXG4gICAgcHJpdmF0ZSB0ZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PixcbiAgICBwcml2YXRlIHJlbmRlcmVyOiBSZW5kZXJlcjIsXG4gICAgcHJpdmF0ZSBzbWFydFBvc2l0aW9uU2VydmljZTogQ2xyUG9wb3ZlclBvc2l0aW9uU2VydmljZSxcbiAgICBwcml2YXRlIHNtYXJ0RXZlbnRzU2VydmljZTogQ2xyUG9wb3ZlckV2ZW50c1NlcnZpY2UsXG4gICAgcHJpdmF0ZSBzbWFydE9wZW5TZXJ2aWNlOiBDbHJQb3BvdmVyVG9nZ2xlU2VydmljZVxuICApIHt9XG5cbiAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5zbWFydE9wZW5TZXJ2aWNlLm9wZW5DaGFuZ2Uuc3Vic2NyaWJlKGNoYW5nZSA9PiB7XG4gICAgICAgIGlmIChjaGFuZ2UpIHtcbiAgICAgICAgICB0aGlzLmFkZENvbnRlbnQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUNvbnRlbnQoKTtcbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICB0aGlzLnNtYXJ0UG9zaXRpb25TZXJ2aWNlLnNob3VsZFJlYWxpZ24uc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgdGhpcy5zaG91bGRSZWFsaWduID0gdHJ1ZTtcbiAgICAgICAgLy8gQXZvaWQgZmxpY2tlcmluZyBvbiBpbml0aWFsaXphdGlvbiwgY2F1c2VkIGJ5IHRoZSBhc3luY2hyb25vdXMgbmF0dXJlIG9mIHRoZVxuICAgICAgICAvLyBjaGVjay1jb2xsZWN0b3IgcGF0dGVybi5cbiAgICAgICAgaWYgKHRoaXMudmlldykge1xuICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUodGhpcy52aWV3LnJvb3ROb2Rlc1swXSwgJ29wYWNpdHknLCAnMCcpO1xuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIC8vIEhlcmUgd2UgY29sbGVjdCBzdWJzZXF1ZW50IHN5bmNocm9ub3VzbHkgcmVjZWl2ZWQgY29udGVudC1jaGVjayBldmVudHMgYW5kIG9ubHkgdGFrZSBhY3Rpb25cbiAgICAgIC8vIGF0IHRoZSBlbmQgb2YgdGhlIGN5Y2xlLiBTZWUgYmVsb3cgZm9yIGRldGFpbHMgb24gdGhlIGNoZWNrLWNvbGxlY3RvciBwYXR0ZXJuLlxuICAgICAgdGhpcy5jaGVja0NvbGxlY3Rvci5waXBlKGRlYm91bmNlVGltZSgwKSkuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgdGhpcy5hbGlnbkNvbnRlbnQoKTtcbiAgICAgICAgdGhpcy5zaG91bGRSZWFsaWduID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLnZpZXcpIHtcbiAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKHRoaXMudmlldy5yb290Tm9kZXNbMF0sICdvcGFjaXR5JywgJzEnKTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5yZW1vdmVDb250ZW50KCk7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLmZvckVhY2goc3ViID0+IHN1Yi51bnN1YnNjcmliZSgpKTtcbiAgfVxuXG4gIHByaXZhdGUgcmVtb3ZlQ29udGVudCgpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMudmlldykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5yZW1vdmVDbGlja0xpc3RlbmVyRm4pIHtcbiAgICAgIHRoaXMucmVtb3ZlQ2xpY2tMaXN0ZW5lckZuKCk7XG4gICAgICB0aGlzLnJlbW92ZUNsaWNrTGlzdGVuZXJGbiA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMudmlldy5yb290Tm9kZXMuZm9yRWFjaChub2RlID0+IHRoaXMucmVuZGVyZXIucmVtb3ZlQ2hpbGQodGhpcy5kb2N1bWVudC5ib2R5LCBub2RlKSk7XG4gICAgdGhpcy5jb250YWluZXIuY2xlYXIoKTtcbiAgICBkZWxldGUgdGhpcy52aWV3O1xuICB9XG5cbiAgLyoqXG4gICAqIFRPRE8obWF0dCk6IGludmVzdGlnYXRlIHdoeSBEZWJ1Z0VsZW1lbnQgcmV0YWlucyBhIHJlZmVyZW5jZSB0byB0aGUgbm9kZXMgYW5kIGNhdXNlcyBhIG1lbW9yeSBsZWFrLlxuICAgKiBBIG5vdGUgYWJvdXQgdGhlIHVzZSBvZiBhcHBlbmRDaGlsZC9yZW1vdmVDaGlsZFxuICAgKiBUaGUgRGVidWdFbGVtZW50IGlzIGtlZXBpbmcgYSByZWZlcmVuY2UgdG8gdGhlIGRldGFjaGVkIG5vZGUgYW5kIGl0cyB1bmNsZWFyIHdoeS5cbiAgICogVGhpcyBkb2VzIHdhcnJhbnQgZnVydGhlciBpbnZlc3RpZ2F0aW9uLiBCdXQsIHNpbmNlIGl0IGRvZXNuJ3QgaGFwcGVuIGluIHByb2R1Y3Rpb24gbW9kZVxuICAgKiBpdCBpcyBhIGxvdyBwcmlvcml0eSBpc3N1ZSBmb3Igbm93LlxuICAgKi9cbiAgcHJpdmF0ZSBhZGRDb250ZW50KCkge1xuICAgIC8vIENyZWF0ZSB0aGUgdmlldyBjb250YWluZXJcbiAgICB0aGlzLnZpZXcgPSB0aGlzLmNvbnRhaW5lci5jcmVhdGVFbWJlZGRlZFZpZXcodGhpcy50ZW1wbGF0ZSk7XG4gICAgY29uc3QgW3Jvb3ROb2RlXSA9IHRoaXMudmlldy5yb290Tm9kZXM7XG4gICAgdGhpcy5zbWFydEV2ZW50c1NlcnZpY2UuY29udGVudFJlZiA9IHJvb3ROb2RlOyAvLyBTbyB3ZSBrbm93IHdoZXJlL3doYXQgdG8gc2V0IGNsb3NlIGZvY3VzIG9uXG4gICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyhyb290Tm9kZSwgJ2Nsci1wb3BvdmVyLWNvbnRlbnQnKTtcbiAgICAvLyBSZXNldCB0byB0aGUgYmVnaW5pbmcgb2YgdGhlIGRvY3VtZW50IHRvIGJlIGF2YWlsYWJsZSBmb3Igc2l6aW5nL3Bvc2l0aW9uaW5nIGNhbGN1bGF0aW9ucy5cbiAgICAvLyBJZiB3ZSBhZGQgbmV3IGNvbnRlbnQgdG8gdGhlIGJvdHRvbSBpdCB0cmlnZ2VycyBjaGFuZ2VzIGluIHRoZSBsYXlvdXQgdGhhdCBtYXkgbGVhZCB0byBmYWxzZSBhbmNob3JcbiAgICAvLyBjb29yZGluYXRlcyB2YWx1ZXMuXG4gICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZShyb290Tm9kZSwgJ3RvcCcsICcwcHgnKTtcbiAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKHJvb3ROb2RlLCAnbGVmdCcsICcwcHgnKTtcbiAgICAvLyBXZSBuZWVkIHRvIGhpZGUgaXQgZHVyaW5nIHRoZSBjYWxjdWxhdGlvbiBwaGFzZSwgd2hpbGUgaXQncyBub3QgeWV0IGZpbmFsbHkgcG9zaXRpb25lZC5cbiAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKHJvb3ROb2RlLCAnb3BhY2l0eScsICcwJyk7XG4gICAgdGhpcy5yZW1vdmVDbGlja0xpc3RlbmVyRm4gPSB0aGlzLnJlbmRlcmVyLmxpc3Rlbihyb290Tm9kZSwgJ2NsaWNrJywgZXZlbnQgPT4ge1xuICAgICAgdGhpcy5zbWFydE9wZW5TZXJ2aWNlLm9wZW5FdmVudCA9IGV2ZW50O1xuICAgIH0pO1xuICAgIHRoaXMudmlldy5yb290Tm9kZXMuZm9yRWFjaChub2RlID0+IHtcbiAgICAgIHRoaXMucmVuZGVyZXIuYXBwZW5kQ2hpbGQodGhpcy5kb2N1bWVudC5ib2R5LCBub2RlKTtcbiAgICB9KTtcbiAgICAvLyBNYXJrIGZvciByZWFsaW5nbWVudCBvbiB0aGUgbmV4dCBjb250ZW50LWNoZWNrIGN5Y2xlLlxuICAgIHRoaXMuc2hvdWxkUmVhbGlnbiA9IHRydWU7XG4gIH1cblxuICBwcml2YXRlIHNob3VsZFJlYWxpZ24gPSBmYWxzZTtcblxuICAvLyBDaGVjay1jb2xsZWN0b3IgcGF0dGVybjpcbiAgLy8gSW4gb3JkZXIgdG8gZ2V0IGFjY3VyYXRlIGNvbnRlbnQgaGVpZ2h0L3dpZHRoIHZhbHVlcywgd2UgY2Fubm90IGNhbGN1bGF0ZSBhbGlnbm1lbnQgb2Zmc2V0cyB1bnRpbFxuICAvLyBhZnRlciB0aGUgcHJvamVjdGVkIGNvbnRlbnQgaGFzIHN0YWJpbGl6ZWQuXG4gIC8vIEFzIG11bHRpcGxlIGNoZWNrIGV2ZW50cyBtYXkgaGFwcGVuIGluIHRoZSBzYW1lIHJlbmRlcmluZyBjeWNsZSwgd2UgbmVlZCB0byBjb2xsZWN0IGFsbCBldmVudHNcbiAgLy8gYW5kIG9ubHkgYWN0IGFmdGVyIHRoZSBjb250ZW50IGlzIHJlYWxseSBzdGFibGUuIE9yIHdlIG1heSBnZXQgd3JvbmcgaW50ZXJtZWRpYXRlIHBvc2l0aW9uaW5nIHZhbHVlcy5cbiAgLy8gV2Ugd2lsbCBjaGFubmVsIHN1YnNlcXVlbnQgY29udGVudCBjaGVjayBldmVudHMgdGhyb3VnaCB0aGlzIG9ic2VydmFibGUuXG4gIHByaXZhdGUgY2hlY2tDb2xsZWN0b3I6IEV2ZW50RW1pdHRlcjx2b2lkPiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICBuZ0FmdGVyQ29udGVudENoZWNrZWQoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuc21hcnRPcGVuU2VydmljZS5vcGVuICYmIHRoaXMudmlldyAmJiB0aGlzLnNob3VsZFJlYWxpZ24pIHtcbiAgICAgIC8vIENoYW5uZWwgY29udGVudC1jaGVjayBldmVudCB0aHJvdWdoIHRoZSBjaGVjay1jb2xsZWN0b3JcbiAgICAgIHRoaXMuY2hlY2tDb2xsZWN0b3IuZW1pdCgpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYWxpZ25Db250ZW50KCkge1xuICAgIGlmICghdGhpcy52aWV3KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHBvc2l0aW9uQ29vcmRzID0gdGhpcy5zbWFydFBvc2l0aW9uU2VydmljZS5hbGlnbkNvbnRlbnQodGhpcy52aWV3LnJvb3ROb2Rlc1swXSk7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZSh0aGlzLnZpZXcucm9vdE5vZGVzWzBdLCAndG9wJywgYCR7cG9zaXRpb25Db29yZHMueU9mZnNldH1weGApO1xuICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUodGhpcy52aWV3LnJvb3ROb2Rlc1swXSwgJ2xlZnQnLCBgJHtwb3NpdGlvbkNvb3Jkcy54T2Zmc2V0fXB4YCk7XG4gICAgdGhpcy5zbWFydE9wZW5TZXJ2aWNlLnBvcG92ZXJBbGlnbmVkRW1pdCh0aGlzLnZpZXcucm9vdE5vZGVzWzBdKTtcbiAgfVxufVxuIl19